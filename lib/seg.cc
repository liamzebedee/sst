/*
 * Structured Stream Transport
 * Copyright (C) 2006-2008 Massachusetts Institute of Technology
 * Author: Bryan Ford
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */


#include <string.h>

#include <QDebug>

#include "host.h"
#include "ident.h"
#include "key.h"
#include "seg.h"

using namespace SST;


////////// FlowSegment //////////

FlowSegment::FlowSegment(Host *host, QObject *parent)
:	Flow(host, parent),
	other(NULL), fsock(NULL), qlim(qlim_default)
{
	connect(this, SIGNAL(readyTransmit()), this, SLOT(gotReadyTransmit()));
}

bool FlowSegment::initiateTo(Socket *sock, const Endpoint &remoteep)
{
	// Bind the segment to the specified socket
	if (!bind(sock, remoteep)) {
		qDebug() << "FlowSegment::initiateTo" << remoteep.toString()
			<< "failed";
		return false;
	}

	// Start the connection process
	KeyInitiator *ki = new KeyInitiator(this, flow_seg_magic,
				Ident::fromEndpoint(remoteep).id());
	(void)ki;
	//connect(ki, SIGNAL(completed(bool)),
	//	this, SLOT(keyCompleted(bool)));

	return true;
}

bool FlowSegment::flowReceive(qint64 pktseq, QByteArray &pkt)
{
	if (pkt.size() <= hdrlen) {
		// It's a standalone acknowledgment packet,
		// generated by the default impl of Flow::transmitAck().
		// Count this explicit ack packet as received,
		// but do NOT send another ack just to ack this ack!
		acknowledge(pktseq, false);
		return false;
	}

	//qDebug() << this << "flowReceive seq" << pktseq << "size" << pkt.size();

	if (fsock) {
		// XXX safer to ack first?
		QByteArray data = pkt.mid(hdrlen);
		qDebug() << fsock << "recv size" << data.size();
		fsock->receive(data, fsock->peer);
		return true;	// go ahead and acknowledge
	}

	// We must be a flow middlebox.
	Q_ASSERT(other);

	// Stash the packet in our queue until the next segment takes it.
	// Implement a basic drop-tail policy for the moment.
	if (rxq.size() >= qlim) {
		qDebug("flow middlebox queue overflow; dropping packet");
		return false;
	}
	RxPkt rp;
	rp.rxseq = pktseq;
	rp.pkt = pkt;
	rxq.enqueue(rp);

	// Notify the downstream segment
	Q_ASSERT(other->other == this);
	other->readyTransmit();

	return false;
}

void FlowSegment::gotReadyTransmit()
{
	if (fsock) {
		// Pass the ready indication on up the stack.
		return fsock->readyTransmitToPeer();
	}

	// We must be a flow middlebox.
	Q_ASSERT(other);

	while (mayTransmit()) {
		if (other->rxq.empty())
			return;		// nothing to transmit

		// Dequeue a packet from the upstream segment
		RxPkt rp = other->rxq.dequeue();

		// Transmit it onto the downstream segment
		quint64 txseq;
		flowTransmit(rp.pkt, txseq);

		// Now we can finally acknowledge it on the previous segment
		other->acknowledge(rp.rxseq, true);
	}
}


////////// FlowSocket //////////

FlowSocket::FlowSocket(Host *host, const QHostAddress &peer, QObject *parent)
:	Socket(host, parent),
	h(host),
	fseg(NULL),
	peer(SocketEndpoint(Endpoint(peer, NETSTERIA_DEFAULT_PORT), this))
{
	setActive(true);	// XXX should we already???

	qDebug() << this << "active sockets" << host->activeSockets();
}

FlowSocket::~FlowSocket()
{
	qDebug() << this << "~FlowSocket";
}

void FlowSocket::initiateTo(const Endpoint &remoteep)
{
	Q_ASSERT(fseg == NULL);
	fseg = new FlowSegment(host(), this);
	fseg->fsock = this;
	Q_ASSERT(fseg->other == NULL);

	// Bind the segment to the host's main socket
	if (!fseg->initiateTo(host()->activeSockets().at(0), remoteep))
		qFatal("FlowSocket::initiateTo failed");//XXX
}

// XXX unused
void FlowSocket::keyCompleted(bool success)
{
	if (!success)
		qFatal("FlowSocket key agreement failed!"); //XXX

	qDebug() << "FlowSocket key agreement succeeded";
}

bool FlowSocket::bindFlow(const Endpoint &remoteep, Channel localchan,
			SocketFlow *flow)
{
	if (remoteep != peer) {
		qDebug() << "Can't bind flow to" << remoteep.toString()
			<< "over FlowSocket to" << peer.toString();
		return false;
	}

	if (!Socket::bindFlow(remoteep, localchan, flow))
		return false;

	// Propagate the underlying flow's readyTransmit() signal upward
	connect(this, SIGNAL(readyTransmitToPeer()),
		flow, SIGNAL(readyTransmit()));

	return true;
}

bool FlowSocket::send(const Endpoint &ep, const char *data, int size)
{
	qDebug() << this << "send to" << ep << "size" << size;

	Q_ASSERT(ep == peer);
	Q_ASSERT(fseg);

	if (!fseg->isActive()) {
		qDebug() << this << "send: dropping packet for inactive flow";
		return false;
	}

	QByteArray pkt;
	pkt.resize(fseg->hdrlen + size);
	memcpy(pkt.data() + fseg->hdrlen, data, size);

	quint64 txseq;
	return fseg->flowTransmit(pkt, txseq);
}

bool FlowSocket::isCongestionControlled(const Endpoint &)
{
	return true;
}

int FlowSocket::mayTransmit(const Endpoint &ep)
{
	Q_ASSERT(ep == peer);

	return fseg->mayTransmit();
}

bool FlowSocket::bind(const QHostAddress &, quint16, QUdpSocket::BindMode)
{
	qFatal("FlowSocket::bind() shouldn't be called");//XXX???
	return false;
}

QList<Endpoint> FlowSocket::localEndpoints()
{
	qFatal("FlowSocket::localEndpoints() shouldn't be called");//XXX???
	return QList<Endpoint>();
}

quint16 FlowSocket::localPort()
{
	qFatal("FlowSocket::localPort() shouldn't be called");//XXX???
	return 0;
}

QString FlowSocket::errorString()
{
	qFatal("FlowSocket::errorString() shouldn't be called");//XXX???
	return QString();
}

////////// FlowResponder //////////

FlowResponder::FlowResponder(Host *h)
:	KeyResponder(h, flow_seg_magic),
	fsock(NULL)
{
}

void FlowResponder::forwardTo(const Endpoint &targetep)
{
	this->targetep = targetep;
}

void FlowResponder::forwardUp(FlowSocket *fsock)
{
	this->fsock = fsock;
}

Flow *FlowResponder::newFlow(const SocketEndpoint &epi, const QByteArray &,
				const QByteArray &, QByteArray &)
{
	FlowSegment *fseg = new FlowSegment(host(), this);

	// Bind the flow to the socket the request came in on.
	if (!fseg->bind(epi)) {
		qDebug("FlowResponder: could not bind new flow");
		delete fseg;
		return NULL;
	}

	// Set up the onward or upward forwarding path
	if (fsock) {
		fseg->fsock = fsock;	// just forward up to this socket
		fseg->setParent(fsock);

		Q_ASSERT(fsock->fseg == NULL);	// XXX
		fsock->fseg = fseg;

	} else {
		// Initiate a corresponding outgoing flow
		Q_ASSERT(!targetep.isNull());
		FlowSegment *oseg = new FlowSegment(host(), this);
		if (!oseg->initiateTo(epi.sock, targetep)) {
			qDebug() << "FlowResponder: couldn't initiate to next"
				<< targetep.toString();
			delete fseg;
			return NULL;
		}
		oseg->other = fseg;
		fseg->other = oseg;
	}

	return fseg;
}

